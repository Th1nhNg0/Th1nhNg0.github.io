[{"categories":["programming"],"content":"Tổng hợp các thủ thuật C++","date":"05-11-2020","objectID":"/cpp-tip-trick/","tags":["C++","IT","Competitive programming"],"title":"C++ tips \u0026 tricks","uri":"/cpp-tip-trick/"},{"categories":["programming"],"content":"Mở đầu Xin chào, bài viết này tóm tắt lại vài thủ thuật hay ho mà mình học được khi chuyển từ pascal sang C++. Đa số những thủ thuật này được sử dụng trong CP (Competitive programming). Template mình thường dùng #include \u003cbits/stdc++.h\u003e // inlucde tất cả thư viện có thể sử dụng khi đi CPusing namespace std; int main() { freopen(\"input.txt\", \"r\", stdin); // Đọc file bằng cin freopen(\"output.txt\", \"w\", stdout); // Xuất file bằng cout ios_base::sync_with_stdio(false); cin.tie(NULL); // Đọc xuất file nhanh // Code ở đây // Thời gian chạy của thuật toán cerr \u003c\u003c \"time taken : \" \u003c\u003c (float)clock() / CLOCKS_PER_SEC \u003c\u003c \" secs \\n\"; return 0; } Sử dụng marco để code nhanh hơn Ví dụ: long long x=4; pair\u003clong long,long long\u003e k; vector\u003clong long\u003e a; Có thể chuyển thành #define ll long long ll x=4; pair\u003cll, ll\u003e k; vector\u003cll\u003e a; So sánh endl và '\\n' cout\u003c\u003cendl; // In ký tự xuống dòng và flush stream cout\u003c\u003c'\\n'; // Chỉ in ký tự xuống dòng Ta thấy, sử dụng '\\n' sẽ nhanh hơn rất nhiều khi in một lượng lớn ký tự xuống dòng. Thực vậy, thử với 2 chương trình sau: for (int i = 0; i \u003c 1000000; i++) cout \u003c\u003c endl; // Run time: 2.463 secs for (int i = 0; i \u003c 1000000; i++) cout \u003c\u003c '\\n'; // Run time: 0.093 secs Hàm ước chung lớn nhất có sẵn Trong C++, có hàm __gcd(m,n) trả về giá trị ước chung lớn nhất của 2 số m và n. Độ phức tạp của thuật toán này là $ O(\\log_{2}{max(n,m)}) $. Sử dụng auto Từ phiên bản C++11 trở về sau, từ khóa auto được dùng để tự động nhận dạng kiểu dữ liệu thông qua kiểu dữ liệu của giá trị khởi tạo ra nó. auto a = 1; // 1 là kiểu int =\u003e a kiểu int auto b = 1.0F; // 1.0F là kiểu float =\u003e b kiểu float auto c = 1.0; // 1.0 là kiểu double =\u003e c kiểu double Độ dài tối đa của array Khi khai báo array trong hàm main() thì độ dài tối đa là $ 10^{6} $ nhưng khi ta khai báo biến toàn cục thì độ dài có thể lên tới $ 10^{7} $. Thư viện STL Thư viện STL là thứ mà mình thấy xịn nhất từ trước tới nay khi mình chuyển từ Pascal qua. Nó gần như giải quyết được mọi vấn đề mà Pascal phải tốn rất nhiều công sức mới làm được ^_^ ","date":"05-11-2020","objectID":"/cpp-tip-trick/:0:0","tags":["C++","IT","Competitive programming"],"title":"C++ tips \u0026 tricks","uri":"/cpp-tip-trick/"},{"categories":["programming"],"content":"Vector Vector làm việc giống như một “mảng động”. Khai báo: vector\u003ckiểu_dữ_liệu\u003e tên_biến. Sử dụng vector sẽ tốt khi: Truy cập đến phần tử riêng lẻ thông qu a vị trí của nó $ O(1) $ Chèn hay xóa ở vị trí cuối cùng $ O(1) $. Tìm hiểu thêm về Vector ","date":"05-11-2020","objectID":"/cpp-tip-trick/:1:0","tags":["C++","IT","Competitive programming"],"title":"C++ tips \u0026 tricks","uri":"/cpp-tip-trick/"},{"categories":["programming"],"content":"Priority Queue (Hàng đợi ưu tiên) Priority queue là một loại container adaptor, được thiết kế đặc biệt để phần tử ở đầu luôn luôn lớn nhất (theo một quy ước về độ ưu tiên nào đó) so với các phần tử khác. Khai báo: priority_queue \u003c int \u003e pq; // mặc định là lớn nhất // Sử dụng hàm so sánh khác priority_queue \u003c int,vector\u003cint\u003e,greater\u003cint\u003e \u003e q; Sử dụng priority queue sẽ tốt khi: Vừa thêm phần từ, vừa lấy phần tử lớn nhất (nhỏ nhất) ra. Thao tác thêm phần tử chỉ mất $ O(\\log{n})$ Tăng tốc độ thuật toán Dijkstra Tìm hiểu thêm về Priority Queue ","date":"05-11-2020","objectID":"/cpp-tip-trick/:2:0","tags":["C++","IT","Competitive programming"],"title":"C++ tips \u0026 tricks","uri":"/cpp-tip-trick/"},{"categories":["programming"],"content":"Set Set là một loại associative containers để lưu trữ các phần tử không bị trùng lặp (unique elements), và các phần tử này chính là các khóa (keys). Khai báo tương tự Priority Queue: set \u003cint\u003e s; set \u003cint, greater\u003cint\u003e \u003e s; Tìm hiểu thêm về Set ","date":"05-11-2020","objectID":"/cpp-tip-trick/:3:0","tags":["C++","IT","Competitive programming"],"title":"C++ tips \u0026 tricks","uri":"/cpp-tip-trick/"},{"categories":["programming"],"content":"Map Map là một loại associative container. Mỗi phần tử của map là sự kết hợp của khóa (key value) và ánh xạ của nó (mapped value). Cũng giống như set, trong map không chứa các khóa mang giá trị giống nhau. Khai báo: map \u003c kieu_du_lieu_1 , kieu_du_lieu_2 \u003e m; // kieu_du_lieu_1 là khóa, kieu_du_lieu_2 là giá trị của khóa. //Sử dụng class so sánh: struct cmp{ bool operator() (char a,char b) {return a\u003cb;} }; map \u003cchar,int,cmp\u003e m; Tìm hiểu thêm về Map ","date":"05-11-2020","objectID":"/cpp-tip-trick/:4:0","tags":["C++","IT","Competitive programming"],"title":"C++ tips \u0026 tricks","uri":"/cpp-tip-trick/"},{"categories":["programming"],"content":"Thư viện thuật toán Khai báo sử dụng: #include \u003calgorithm\u003e ","date":"05-11-2020","objectID":"/cpp-tip-trick/:5:0","tags":["C++","IT","Competitive programming"],"title":"C++ tips \u0026 tricks","uri":"/cpp-tip-trick/"},{"categories":["programming"],"content":"Sắp xếp: sort: sắp xếp đoạn phần tử theo một trình tự nào đó. Mặc định của sort là sử dụng operator \u003c. Bạn có thể sử dụng hàm so sánh, hay class so sánh tự định nghĩa để sắp xếp cho linh hoạt. int myints[] = {32,71,12,45,26,80,53,33}; sort (myints, myints+4); // (12 32 45 71)26 80 53 33 sort (myints, myints+8); // 12 26 32 33 45 53 71 80 ","date":"05-11-2020","objectID":"/cpp-tip-trick/:5:1","tags":["C++","IT","Competitive programming"],"title":"C++ tips \u0026 tricks","uri":"/cpp-tip-trick/"},{"categories":["programming"],"content":"Tìm kiếm nhị phân binary_search: tìm kiếm xem khóa có trong đoạn cần tìm không. Lưu ý: đoạn tìm kiếm phải được sắp xếp theo một trật tự nhất đinh. Nếu tìm được sẽ return true, ngược lại return false. Dạng 1: binary_search(vị trí bắt đầu, vị trí kết thúc, khóa) Dạng 2: binary_search(vị trí bắt đầu, vị trí kết thúc, khóa, phép so sánh) lower_bound: trả về iterator đến phần tử đầu tiên trong nửa đoạn [first,last] mà không bé hơn khóa tìm kiếm. Dạng 1: lower_bound( vị trí bắt đầu, vị trí kết thúc, khóa ) Dạng 2: lower_bound( vị trí bắt đầu, vị trí kết thúc, khóa , phép toán so sánh) upper_bound: trả về iterator đến phần tử đầu tiên trong nửa đoạn [first,last] mà lớn hơn khóa tìm kiếm. Dạng 1: upper_bound( vị trí bắt đầu, vị trí kết thúc, khóa ) Dạng 2: upper_bound( vị trí bắt đầu, vị trí kết thúc, khóa , phép toán so sánh) Và còn nhiều thuật toán nữa. Xem thêm về thư viện thuật toán ","date":"05-11-2020","objectID":"/cpp-tip-trick/:5:2","tags":["C++","IT","Competitive programming"],"title":"C++ tips \u0026 tricks","uri":"/cpp-tip-trick/"},{"categories":["programming"],"content":"Xem thêm thư viện STL http://www.cplusplus.com/reference/stl/?kw=stl ","date":"05-11-2020","objectID":"/cpp-tip-trick/:6:0","tags":["C++","IT","Competitive programming"],"title":"C++ tips \u0026 tricks","uri":"/cpp-tip-trick/"},{"categories":null,"content":"Xin chào, cảm ơn bạn đã ghé qua blog của mình. Mình vẫn chưa biết viết gì ở blog này nhưng mà mình nghĩ sẽ có nhiều thứ hay ho lắm. Các bạn cùng đón chờ nhé \u003c3 Mèo méo meo mèo meo ","date":"04-11-2020","objectID":"/first-post/:0:0","tags":null,"title":"First post","uri":"/first-post/"},{"categories":null,"content":" Chào mừng đến với blog của mình Mình tên là Ngô Phú Thịnh, 19 tuổi. Mình đến từ Cà Mau, nơi cuối bản đồ Việt Nam :\u003e Sinh viên năm 2 khoa toán tin trường Đại học Khoa học Tự Nhiên ĐHQG TP.HCM Mình thích lập trình, toán và guitar Mục đích mình tạo ra blog này Thấy vui nên làm thử :D ","date":"08-02-2019","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"Chỗ này tổng hợp các câu hỏi hóc búa trong cuộc sống mà mình thấy thắc mắc :D ","date":"01-01-0001","objectID":"/hoingu/:0:0","tags":null,"title":"Hỏi ngu","uri":"/hoingu/"},{"categories":null,"content":"1.Tại sao khi thổi “hù” thì ra hơi mát, thổi “hà” lại ra hơi nóng? Trả lời:Khi mím môi thổi “hù”, không khí thoát ra khỏi miệng rất nhanh và có xu hướng hòa vào không khí xung quanh nó. Vì vậy luồng hơi đa số là không khí xung quanh, bạn sẽ không cảm thấy nóng vì luồng hơi di chuyển nhanh có xu hướng đẩy luồng khí nóng đi nơi khác. Khi thổi “hà”, không khí di chuyển chậm và mượt hơn. Ít bị hòa với không khí xung quanh. Vì vậy bạn có thể cảm nhận hơi nóng của luồng khí đi ra từ phổi của bạn. Hãy thử để tay thật sát miệng và thổi “hù”, bạn sẽ cảm nhận được 1 chút ấm ấm vì luồng hơi đó chưa kịp hòa với không khí xung quanh :vv ","date":"01-01-0001","objectID":"/hoingu/:1:0","tags":null,"title":"Hỏi ngu","uri":"/hoingu/"}]